route map:

1. warden A enters his university ID number and pswd and gets a token back which is used in authentication.

2. warden A sees a list of free sessions available with warden B.

3. warden A picks one of the above slots and books.

4. warden B logins in with his university ID and pswd. Gets his token generated.

5. warden B sees a list of all pending sessions - warden name, and slot details. Currently only A is booked.

6. warden C logs in, gets a list of free slots and books a slot.

7. warden B logs in back and sees a list of his booked sessions.

8. warden b logs in back after slot time booked by A ( purge A from db ) and he can see only C in the list. manually edit db.




1. const express = require('express');
    This line imports the Express.js library and assigns it to the variable express, allowing you to create an Express application.

2. const bodyParser = require('body-parser');
    This line imports the body-parser middleware, which is used to parse the incoming request body. 
    It's essential for handling data sent in HTTP POST requests.

3. const pool = require("./postbase.js");
    This line imports a module named postbase.js. 
    It seems like this module is responsible for creating and managing a connection pool to a PostgreSQL database. 
    The pool variable likely holds a database connection pool, allowing you to interact with the database.

4. const port = 8069;
    This line defines the port on which your Express application will listen for incoming HTTP requests. 
    It sets the port number to 8069

5. const app = express()
    Here, you create an instance of an Express application and assign it to the variable app. 
    This app object will be used to configure and define your application's routes and behaviors.

6. app.use(bodyParser.urlencoded({ extended: true }));
    This line configures the Express application to use the body-parser middleware for parsing URL-encoded data.
    The extended: true option allows parsing of rich objects and arrays encoded in the URL-encoded format, not just strings.

7. app.use(bodyParser.json());
    This line configures the Express application to use the body-parser middleware for parsing JSON data.
    It enables the application to automatically parse JSON data sent in HTTP request bodies.

8. /:universalURL
    It's a way to handle requests to undefined or unknown routes and provide a consistent error message.

9. CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    This extension provides support for Universally Unique Identifiers (UUIDs) in PostgreSQL.
    So, when you execute this SQL command, it checks if the "uuid-ossp" extension exists in the database, and if not, it creates it. 
    If it already exists, it has no effect, ensuring that you don't accidentally create duplicate extensions.

10. SERIAL PRIMARY KEY
     "SERIAL PRIMARY KEY" is a common way to create an auto-incrementing, unique identifier for each row in a PostgreSQL table. 
     It combines the benefits of automatic value generation with the requirement of uniqueness and integrity that comes with being a primary key.

11. module.exports = app;
    you are specifying what should be available to other modules that require this module

12. router.post('/)
     POST request handler for route /

13. const { university_id, password } = req.body;
    It expects data to be sent in the request body with two properties: university_id and password.
    These values are extracted from the request body.

14. pool.query
    is a method to perform a PSQL query on a database. 
    This query checks if a warden with the provided university_id and password exists in the 'Wardens' table.

15. result.rows.length
    It checks the result.rows.length property to determine if any rows were returned by the query. 
    If no rows were found, it means that the warden with the provided credentials does not exist, and it responds with a 401 (Unauthorized) status and an error message.

16. tokenResult.rows[0].token
    It extracts the generated token from tokenResult.rows[0].token and checks if it exists. 
    If a token is generated successfully, it responds with a JSON object containing the generated token.

17. status 500
    request cannot be fulfilled

18. status 401
    Unauthorized because of invalid creds.





